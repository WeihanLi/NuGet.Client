// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using NuGet.Common;
using NuGet.Packaging.Core;
using NuGet.Protocol.Core.Types;
using NuGet.Versioning;

namespace NuGet.Protocol
{
    public class VulnerabilityInfoResource : INuGetResource
    {
        private Dictionary<string, List<NuGetVersion>> _vulnerablePackages;

        private readonly HttpSource _client;
        private readonly Uri _vulnerabilityEndpoint;
        private readonly SourceRepository _sourceRepository;

        public VulnerabilityInfoResource(HttpSource client, Uri vulnerabilityEndpoint, SourceRepository source)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
            _vulnerabilityEndpoint = vulnerabilityEndpoint ?? throw new ArgumentNullException(nameof(vulnerabilityEndpoint));
            _sourceRepository = source ?? throw new ArgumentNullException(nameof(source));
        }

        public async Task<bool> IsPackageVulnerable(
            PackageIdentity packageIdentity,
            ILogger log,
            CancellationToken cancellationToken)
        {
            var vulnerablePackages = await GetVulnerabilityInformation(
                (httpSource, uri) => httpSource.ProcessHttpStreamAsync(
                    new HttpSourceRequest(uri, log),
                    s => ProcessStream(s, cancellationToken),
                    log,
                    cancellationToken),
                log,
                cancellationToken);


            _vulnerablePackages = new();

            foreach (var entry in vulnerablePackages)
            {
                if (_vulnerablePackages.ContainsKey(entry.Id))
                {
                    _vulnerablePackages[entry.Id].Add(entry.Version);
                }
                else
                {
                    _vulnerablePackages.Add(entry.Id, new List<NuGetVersion>() { entry.Version });
                }
            }

            if (_vulnerablePackages.TryGetValue(packageIdentity.Id, out var versionList) && versionList.Contains(packageIdentity.Version))
            {
                return true;
            }
            return false;

        }

        private async Task<T> GetVulnerabilityInformation<T>(
            Func<HttpSource, Uri, Task<T>> getResultAsync,
            ILogger log,
            CancellationToken cancellationToken)
        {
            return await SearchPage(
                uri => getResultAsync(_client, uri),
                log,
                cancellationToken);
        }

        private async Task<T> SearchPage<T>(
                    Func<Uri, Task<T>> getResultAsync,
                    ILogger log,
                    CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var endpoint = _vulnerabilityEndpoint;

            var queryUrl = new UriBuilder(endpoint.AbsoluteUri);
            //var queryString =
            //    "q=" + searchTerm +
            //    "&skip=" + skip.ToString() +
            //    "&take=" + take.ToString();
            //queryUrl.Query = queryString;

            T searchResult;
            try
            {
                log.LogVerbose($"Querying {queryUrl.Uri}");

                searchResult = await getResultAsync(queryUrl.Uri);
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (JsonReaderException ex)
            {
                throw new FatalProtocolException(string.Format(CultureInfo.CurrentCulture, Strings.Protocol_MalformedMetadataError, queryUrl.Uri), ex);
            }
            catch (HttpRequestException ex)
            {
                throw new FatalProtocolException(string.Format(CultureInfo.CurrentCulture, Strings.Protocol_BadSource, queryUrl.Uri), ex);
            }

            if (searchResult != null)
            {
                return searchResult;
            }

            throw new FatalProtocolException("Something went really really really wrong :D");
        }


        internal async Task<List<PackageMetadata>> ProcessStream(HttpResponseMessage httpInitialResponse, CancellationToken token)
        {
            return (await ProcessHttpStreamWithoutBufferingAsync(httpInitialResponse, token)).Data;
        }

        private async Task<VulnerabilityResults> ProcessHttpStreamWithoutBufferingAsync(HttpResponseMessage httpInitialResponse, CancellationToken token)
        {
            if (httpInitialResponse == null)
            {
                return null;
            }
            var _newtonsoftConvertersSerializer = JsonSerializer.Create(JsonExtensions.ObjectSerializationSettings);

            using var stream = await httpInitialResponse.Content.ReadAsStreamAsync();
            using var streamReader = new StreamReader(stream);
            using var jsonReader = new JsonTextReader(streamReader);
            return _newtonsoftConvertersSerializer.Deserialize<VulnerabilityResults>(jsonReader);
        }

        internal class VulnerabilityResults
        {
            [JsonProperty("data")]
            public List<PackageMetadata> Data { get; private set; } = new List<PackageMetadata>();
        }

        internal class PackageMetadata
        {
            [JsonProperty(PropertyName = JsonProperties.PackageId)]
            [JsonConverter(typeof(MetadataFieldConverter))]
            public string Id { get; private set; }

            [JsonProperty(PropertyName = JsonProperties.Version)]
            public NuGetVersion Version { get; private set; }
        }

        private async Task<JObject> StuffAsync(ILogger log, ServiceIndexEntry serviceEntry, CancellationToken token)
        {
            var cacheKey = GenerateCacheKey(serviceEntry);

            const int maxRetries = 3;
            for (var retry = 1; retry <= maxRetries; retry++)
            {
                using (var sourceCacheContext = new SourceCacheContext())
                {
                    var cacheContext = HttpSourceCacheContext.Create(sourceCacheContext, isFirstAttempt: retry == 1);

                    try
                    {
                        return await _client.GetAsync(
                            request: new HttpSourceCachedRequest(
                                serviceEntry.Uri.AbsoluteUri,
                                cacheKey,
                                cacheContext)
                            {
                                EnsureValidContents = stream => HttpStreamValidation.ValidateJObject(_vulnerabilityEndpoint.AbsoluteUri, stream),
                                MaxTries = 1,
                                IsRetry = retry > 1,
                                IsLastAttempt = retry == maxRetries
                            },
                            processAsync: async httpSourceResult =>
                            {
                                var json = await httpSourceResult.Stream.AsJObjectAsync(token);
                                return json;
                            },
                            log: log,
                            token: token);
                    }
                    catch (Exception ex) when (retry < maxRetries)
                    {
                        var message = string.Format(CultureInfo.CurrentCulture, "TODO NK - Strings.Log_RetryingRepositorySignature", _vulnerabilityEndpoint.AbsoluteUri)
                            + Environment.NewLine
                            + ExceptionUtilities.DisplayMessage(ex);
                        log.LogMinimal(message);
                    }
                    catch (Exception ex) when (retry == maxRetries)
                    {
                        var message = string.Format(CultureInfo.CurrentCulture, "TODO NK - Strings.Log_FailedToReadRepositorySignature", _vulnerabilityEndpoint.AbsoluteUri);

                        throw new FatalProtocolException(message, ex);
                    }
                }
            }
            return null;
        }


        private static string GenerateCacheKey(ServiceIndexEntry serviceEntry)
        {
#if NETCOREAPP
            var index = serviceEntry.Type.IndexOf('/', StringComparison.Ordinal);
#else
            var index = serviceEntry.Type.IndexOf('/');
#endif
            var version = serviceEntry.Type.Substring(index + 1).Trim();

            return $"vulnerability_info_{version}";
        }
    }

}
